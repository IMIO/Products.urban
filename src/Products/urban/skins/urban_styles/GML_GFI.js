/**
 * @requires OpenLayers/Format/GML.js
 **/
 
 /**
 * Class: OpenLayers.Format.GML_GFI
 * Extends GML Format Class To Read GetFeatureInfo Responses. Create a new instance with the <OpenLayers.Format.GML_GFI>
 *     constructor.  Inherts all other methods & properties from Format.GML
 * 
 * Inherits from:
 *  - <OpenLayers.Format.GML>
 */
OpenLayers.Format.GML_GFI = OpenLayers.Class(OpenLayers.Format.GML, {
 /**
 * Property: responseNS
 * {String} The namespace URI for response generated by a mapsever. Default is * which works for any namespace.
 */ 
    responseNS: '*',
 /**
 * Property: layerNS
 * {String} The namespace URI for layer node(s). Default is * which works for any namespace.
 */
    layerNS: '*',
 /**
 * Property: featureNS
 * {String} The namespace URI for feature nodes. Default is * which works for any namespace.
 */     
    featureNS: '*',
/**
 * Property: layerIdentifier
 *  {String} A search string to locate in the tagName property of xml nodes. All xml nodes containing
 *  this search criteria will populate an internal array of layer nodes.
 */ 
    layerIdentifier: '_layer',
/**
 * Property: featureIdentifier
 *  {String} A search string to locate in the tagName property of xml nodes. All xml nodes containing
 *  this search criteria will populate an internal array of feature nodes for each layer node found.
 */
    featureIdentifier: '_feature',
 /**
 * Constructor: OpenLayers.Format.GML_GFI
 * Create a new parser for a GML formated GetFeatureInfo response.
 *
 * Parameters:
 * options - {Object} An optional object whose properties will be set on
 *     this instance.
 */
    initialize: function(options){
        OpenLayers.Format.GML.prototype.initialize.apply(this, [options]);
    },
 
 /**
 * Method: Read
 * Read data from a string and returns an object with the following structure:
 *
 *{layerName:'the layer name',
 * features:Array(<OpenLayers.Feature.Vector>)
 *}
 *
 *Note: The GetFeatureInfo response, even in GML, is not standardized
 *across different WMS implementions. This is currently based soley on
 *a default GML response from Mapserver 5 only. Geoserver, ArcGIS Server,
 *PostGIS, etc.. could have very different responses that this would
 *not handle properly. Also, one could modify the Mapserver response
 *via Metadata parameters in the mapfile such that it would be difficult
 *for this function to produce good results.
 *
 *Parameters:
 *data - {String} or {DOMElement} data to read/parse.
 *
 *Returns:
 *Array(Object)  [{layerName:'the layer name', features:Array(<OpenLayers.Feature.Vector>)},...]
 *
 */
    read: function(data){
        var featureArray, gfiResponseObj = [];
        var layerNodes, layerIdent, featureNodes, n, i, j;
        if (typeof data == "string") {
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
        }
        layerNodes = this.getSiblingNodesByTagCriteria(data.documentElement, this.layerIdentifier);
        n = layerNodes.length;
        if (layerNodes && layerNodes.length > 0) {
            for (i = 0; i < n; i++) {
                var layerObj = {
                    'layerName': '',
                    'features': []
                };
                var layerName = layerNodes[i].nodeName;
                if (layerNodes[i].prefix) {
                    layerName = layerName.split(':')[1]
                };
                if (this.layerIdentifier != null && this.layerIdentifier != '') {
                    layerName = layerName.replace(this.layerIdentifier, '');
                }
                layerObj.layerName = layerName;
                featureNodes = this.getSiblingNodesByTagCriteria(layerNodes[i], this.featureIdentifier);
                for (j = 0; j < featureNodes.length; j++) {
                    var geom = this.parseGeometry(featureNodes[j]);
                    var attributes = this.parseAttributes(featureNodes[j]);
                    layerObj.features.push(new OpenLayers.Feature.Vector(geom, attributes, null));
                }
                gfiResponseObj.push(layerObj);
            }
            return gfiResponseObj;
        }
    },
    
    /**
     * Method: getSiblingNodesByTagCriteria
     * Recursively searches passed xml node and all it's descendant levels for 
     * nodes whose tagName contains the passed search string. This returns an 
     * array of all sibling nodes which match the criteria from the highest 
     * hierarchial level from which a match is found.
     * 
     * Parameters:
     * node - {DOMElement} An xml node
     * criteria - {String} Search string which will match some part of a tagName          
     *                                       
     * Returns:
     * Array({DOMElement)) An array of sibling xml nodes
     */                
    getSiblingNodesByTagCriteria: function(node, criteria){
        var nodes = [];
        var children, tagName, n, i, matchNodes, child;
        if (node && node.hasChildNodes()) {
            children = node.childNodes;
            child = children[0];
            while (child.nodeType != 1) {
                child = child.nextSibling;
            }
            tagName = child.nodeName;
            if (tagName.length && tagName.length > 0 && tagName.indexOf(criteria) > -1) {
                n = children.length;
                for (var i = 0; i < n; i++) {
                    child = children[i];
                    if (child.nodeType == 1) 
                        nodes.push(child);
                }
            }
            else {
                n = children.length;
                for (var i = 0; i < n; i++) {
                    matchNodes = this.getSiblingNodesByTagCriteria(children[i], criteria);
                    (nodes.length == 0) ? nodes = matchNodes : nodes.push(matchNodes);
                }
            }
        }
        return nodes;
    },
 /**
 * Method: parseGeometry
 * Given a GML node representing a coordinate series, create either and OpenLayers
 *     point geometry or an OpenLayers polygon geometry, depending on the coordinates.
 *
 * Parameters:
 * node - {DOMElement} A GML node.
 *
 * Returns:
 * {<OpenLayers.Geometry.Point>} A point geometry or {<OpenLayers.Geometry.Polygon>} A bounding box polygon.
 */
    parseGeometry: function(node){
        var nodeList, coordString;
        var coords = [];
        nodeList = this.getElementsByTagNameNS(node, this.gmlns, "coordinates");
        if (nodeList.length > 0) {
            coordString = nodeList[0].firstChild.nodeValue;
            coords = coordString.match(/\d+\.\d+/g);
        }
        if (coords.length > 0) {
            if ((coords.length == 4 && coords[0] == coords[2] && coords[1] == coords[3]) || coords.length == 2) {
                if (this.xy) {
                    return new OpenLayers.Geometry.Point(coords[0], coords[1]);
                }
                else {
                    return new OpenLayers.Geometry.Point(coords[1], coords[0]);
                }
            }
            else 
                if (coords.length == 4) {
                    return new OpenLayers.Bounds(coords[0], coords[1], coords[2], coords[3]).toGeometry();
                }
                else {
                    return null;
                }
        }
    },
    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {<DOMElement>}
     *
     * Returns:
     * {Object} An attributes object.
     * 
     * Notes:
     * Assumes that attributes are direct child xml nodes of the passed node
     * and contain only a single text node. 
     *      
     * This differs slightly from the GML parser which expects attributes to 
     * be grandchildern nodes of the passed node and only works with the first
     * node set it can find.                             
     */    
    parseAttributes: function(node){
        var attributes = {};
        var children, i, n, child, grandchildren, grandchild, name, value;
        if (node.nodeType == 1) {
            children = node.childNodes;
            n = children.length
            for (i = 0; i < n; ++i) {
                child = children[i];
                if (child.nodeType == 1) {
                    grandchildren = child.childNodes;
                    if (grandchildren.length == 1) {
                        grandchild = grandchildren[0];
                        if (grandchild.nodeType == 3 || grandchild.nodeType == 4) {
                            name = (child.prefix) ? child.nodeName.split(":")[1] : child.nodeName;
                            value = grandchild.nodeValue.replace(this.regExes.trimSpace, "");
                            attributes[name] = value;
                        }
                    }
                }
            }
        }
        else {
            attributes["error"] = "Invalid node type passed as parameter";
        }
        return attributes;
    },
    CLASS_NAME: "OpenLayers.Format.GML_GFI"
});
